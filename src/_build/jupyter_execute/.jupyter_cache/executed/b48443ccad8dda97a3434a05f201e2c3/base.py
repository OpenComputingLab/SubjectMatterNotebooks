%%capture
try:
    import lcapy
except:
    %pip install lcapy
    
#  https://github.com/dawbarton/pdf2svg
#!brew install pdf2svg

from lcapy import Circuit

cct = Circuit("""
V1 1 0; down
R1 1 2; left=2, i=I_1, v=V_{R_1}
R2 1 3; right=2, i=I_2, v=V_{R_2}
L1 2 0_1; down, i=I_1, v=V_{L_1}
L2 3 0_3; down, i=I_1, v=V_{L_2}
W 0 0_3; right
W 0 0_1; left""")


# Render the circuit
cct.draw(scale=3)

# We can also save a generated circuit diagram to an image file
#cct.draw(scale=3, filename='circuit_diagram.svg')

import lcapy
from lcapy import Circuit

#We can create a schematic for the voltage divider using lcapy
#This has the advantage that circuit description is also a model 
#The model can be analysed and used to calculate voltages and currents, for example,
#  across components if component values and the source voltage are defined

#Figure:  A voltage divider circuit
sch='''
VS 1 0 ; down
W 1 2 ;  right, size=2
R1 2 3 ; down
R2 3 4; down
W 3 5; right
P1 5 6; down,v=V_{out}
W 4 6; right
W 4 0; left
'''

#Demonstrate thate we can write the descriptioon to a file 
fn="voltageDivider.sch"
with open(fn, "w") as text_file:
    text_file.write(sch)

#  and then create the circuit model from the (persisted) file    
cct = Circuit(fn)

cct.sch

#Draw the circuit diagram that corresponds to the schematic description
cct.draw(style='american', draw_nodes=False, label_nodes=False) #american, british, european
#Draw function is defined in https://github.com/mph-/lcapy/blob/master/lcapy/schematic.py
#The styles need tweaking to suit OU convention - this requires a minor patch to lcapy
#Styles defined in https://github.com/mph-/lcapy/blob/master/lcapy/schematic.py#Schematic.tikz_draw

cct.R1.v

#We can't do anything about the order of the variables in the output expression, unfortunately
#It would be neater if sympy sorted fractional terms last but it doesn't...

cct.Voc(3,4)['t']

cct.R2.v

#sympy is a symbolic maths package
from sympy import Symbol, Eq

#If we add .expr to the voltages, we can get the sympy representation of voltage and current equations
# that are automatically derived from the model.
vout_expr = cct.R2.v.expr

vout_expr

out_component = 'R2'

cct[out_component].v.expr

cct.R2.relname

v_r1_expr = cct.R1.v.expr

v_r1_expr

vout = Symbol('V_out')

v_r1_expr.subs(vout_expr, vout)

#I don't know how to get the symbols from the circuit as sympy symbols
# so create them explicitly

v_r1 = Symbol("V_{R_1}")

# Define the equation
Eq( v_r1, v_r1_expr.subs(vout_expr, vout) )

#We can find this from quantities we have derived through analysis of the presented circuit
Eq(vout, vout_expr)

Eq(Symbol('I_{R_1}'), cct.R1.i.expr)

# The following equation is generated by the symbolic analysis...

#We get the following from the circuit analysis, as above...
cct.R2.i.expr

# We note that the circuit analysis returns equal expressions for I_R_1 and I_R_2
# which gives some sort of reinforcement to the idea of Kirchoff's Law...

# The following equation is generated by the symbolic analysis...

Eq(vout, vout_expr)

from sympy import sympify

#This is clunky - is there a proper way of substituting values into lcapy expressions?
Eq(6, sympify(str(vout_expr)).subs([('VS', 24), ('R2', 100)]))

Eq(vout_expr - vout, 0)

from sympy import solve

Eq(Symbol('R1'),solve(sympify(str(vout_expr-vout)),'R1')[0])

#The following equation is generated by the symbolic analysis...

solve(sympify(str(vout_expr-vout)).subs([('VS',24), ('R2',100),('V_out',6)]),'R1')[0]

VALUES = [('VS', 24),
          ('R2', 100),
          ('V_out', 6)]

SOLVE_FOR = 'R1'

Eq(Symbol(SOLVE_FOR), solve(sympify(str(vout_expr-vout)), SOLVE_FOR)[0].subs(VALUES))

#The following result is calculated by the symbolic analysis...

Vs=20; Vout=5
R1=solve(sympify(str(vout_expr-vout)),'R1')[0].subs([('VS',Vs),('V_out',Vout)])

print('For V_S={Vs}V and V_out={Vout}V, we need R1={R1}.'.format(Vs=Vs,Vout=Vout,R1=R1))

def soln(cct, out_component=None, values=None):
    if values is None:
        values={'VS':24, 'R1':'', 'R2':100, 'V_out':6}
    outval=[v for v in values if not values[v]]
    invals=[(v, values[v]) for v in values if values[v] ]
    if len(outval)!=1 or len(invals)!=3:
        return 'oops'
    
    outval = outval[0]
    out_component = out_component if out_component else outval
    vout_expr = cct[out_component].v.expr
    print(vout_expr)
    print(invals)
    return 'Value of {} is {}'.format(outval,
                                      solve(sympify(str(vout_expr-vout)).subs(invals), outval)[0])


soln(cct, 'R2')

soln(cct, 'R2', {'VS':24, 'R2':'', 'R1':300, 'V_out':6})

#We can also explore a simple thing to check the value from a circuit analysis
def cct1(V='24',R1='100',R2='100'):
    R1 = '' if R1 and float(R1) <=0 else R1
    sch='''
    VS 1 0 {V}; down
    W 1 2 ;  right, size=2
    R1 2 3 {R1}; down
    R2 3 4 {R2}; down
    W 3 5; right, size=2
    P1 5 6; down,v=V_{{out}}
    W 4 6; right, size=2
    W 4 0; left
    '''.format(V=V,R1=R1,R2=R2)
    
    cct = Circuit()
    cct.add(sch)
    cct.draw(label_nodes=False)
    
    #The output voltage, V_out is the voltage across R2
    txt='The output voltage, $V_{{out}}$ across $R_2$ is {}V.'.format(cct.R2.v if R1 else V)
    return cct

_ = cct1()

from ipywidgets import interact_manual
cct_w = None

@interact_manual
def i_cct1(V='24', R1='', R2='100'):
    global cct_w
    cct_w = cct1(V=V,R1=R1,R2=R2)
    
#We could then select R and V values and extend the function
# to calculate V_out automatically

i_cct1()

# We could also plot V_out vs R_1 for given V_S and R_2?

cct_w.sch

